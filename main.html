<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Advanced Voice Frequency Art Generator — Updated Cymatics Pond</title>
<style>
/* --------------------------------------------------------------------------
   Original Styles (kept exactly, with no removals) - plus minor additions
   -------------------------------------------------------------------------- */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  height: 100%;
  overflow: hidden;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
  color: #f0f0ff;
  display: flex;
  flex-direction: column;
  position: relative;
  min-height: 100vh;
}

header {
  text-align: center;
  padding: 20px;
  background: rgba(10, 10, 26, 0.7);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid rgba(138, 43, 226, 0.3);
  z-index: 10;
  flex-shrink: 0;
}

h1 {
  font-size: 2.5rem;
  background: linear-gradient(90deg, #8a2be2, #00c9ff);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 10px;
}

.subtitle {
  font-size: 1.1rem;
  opacity: 0.8;
  max-width: 600px;
  margin: 0 auto;
}

.main-container {
  display: flex;
  flex: 1;
  padding: 20px;
  gap: 20px;
  overflow: hidden;
  position: relative;
}

.scroll-container {
  display: flex;
  flex: 1;
  gap: 20px;
  overflow-y: auto;
  padding: 10px;
  margin: -10px;
}

.visualizer-section {
  flex: 3;
  position: relative;
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
  min-height: 500px;
}

.controls-section {
  flex: 1;
  background: rgba(10, 10, 26, 0.75);
  backdrop-filter: blur(10px);
  border-radius: 20px;
  padding: 25px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(138, 43, 226, 0.3);
  display: flex;
  flex-direction: column;
  gap: 25px;
  max-width: 400px;
  min-width: 320px;
}

.section-title {
  font-size: 1.4rem;
  margin-bottom: 15px;
  color: #00c9ff;
  display: flex;
  align-items: center;
  gap: 10px;
}

.section-title i {
  font-size: 1.3rem;
}

.control-group {
  margin-bottom: 20px;
}

.control-row {
  display: flex;
  align-items: center;
  margin-bottom: 15px;
}

.control-label {
  flex: 1;
  font-size: 1rem;
  opacity: 0.9;
  min-width: 120px;
}

.slider {
  flex: 2;
  -webkit-appearance: none;
  height: 8px;
  border-radius: 10px;
  background: linear-gradient(90deg, #8a2be2, #00c9ff);
  outline: none;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 22px;
  height: 22px;
  border-radius: 50%;
  background: #fff;
  cursor: pointer;
  box-shadow: 0 0 10px rgba(138, 43, 226, 0.8);
}

.slider-value {
  width: 50px;
  text-align: right;
  font-weight: bold;
  color: #00c9ff;
  min-width: 60px;
}

.btn-group {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.btn {
  padding: 14px;
  border-radius: 12px;
  border: none;
  background: linear-gradient(90deg, #8a2be2, #00c9ff);
  color: white;
  font-size: 1.1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  position: relative;
  overflow: hidden;
}

.btn:hover {
  transform: translateY(-3px);
  box-shadow: 0 7px 20px rgba(138, 43, 226, 0.6);
}

.btn:active {
  transform: translateY(1px);
}

.btn::after {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 50%, rgba(255,255,255,0) 100%);
  transform: rotate(30deg);
  transition: all 0.6s;
}

.btn:hover::after {
  transform: translateX(100%) rotate(30deg);
}

.btn-record {
  background: linear-gradient(90deg, #ff416c, #ff4b2b);
}

.btn-reset {
  background: linear-gradient(90deg, #00c9ff, #00ff95);
}

.btn-save {
  background: linear-gradient(90deg, #ff9a00, #ffd000);
}

.recording-indicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 15px;
  border-radius: 12px;
  background: rgba(255, 65, 108, 0.2);
  margin-top: 10px;
}

.recording-indicator .dot {
  width: 12px;
  height: 12px;
  background: #ff416c;
  border-radius: 50%;
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0% { opacity: 0.2; }
  50% { opacity: 1; }
  100% { opacity: 0.2; }
}

.countdown {
  font-size: 1.5rem;
  font-weight: bold;
  text-align: center;
  color: #ff416c;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 15;
  background: rgba(0, 0, 0, 0.7);
  padding: 20px 40px;
  border-radius: 20px;
  box-shadow: 0 0 30px rgba(255, 65, 108, 0.5);
}

.freq-analysis {
  background: rgba(0, 201, 255, 0.1);
  border-radius: 15px;
  padding: 20px;
  margin-top: 20px;
}

.freq-title {
  text-align: center;
  margin-bottom: 15px;
  color: #00c9ff;
  font-size: 1.2rem;
}

.freq-details {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.freq-item {
  background: rgba(255, 255, 255, 0.05);
  padding: 12px;
  border-radius: 10px;
  transition: transform 0.3s, box-shadow 0.3s;
}

.freq-item:hover {
  transform: translateY(-5px);
  box-shadow: 0 5px 15px rgba(0, 201, 255, 0.3);
}

.freq-label {
  font-size: 0.9rem;
  opacity: 0.8;
  margin-bottom: 5px;
}

.freq-value {
  font-size: 1.2rem;
  font-weight: bold;
  color: #00c9ff;
}

.visualization-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

/* NEW: container for cymatics canvas - we will insert the canvas here */
#pond-container {
  width: 100%;
  height: 100%;
  position: relative;
  display: flex;
  align-items: stretch;
  justify-content: stretch;
}

.capture-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 20;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.5s ease;
  overflow-y: auto;
  padding: 20px;
}

.capture-overlay.active {
  opacity: 1;
  pointer-events: all;
}

.capture-title {
  font-size: 2.5rem;
  margin-bottom: 20px;
  background: linear-gradient(90deg, #ff416c, #ff8a00);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  text-align: center;
}

.capture-subtitle {
  font-size: 1.2rem;
  margin-bottom: 40px;
  max-width: 600px;
  text-align: center;
  line-height: 1.6;
}

.voice-image {
  width: 400px;
  height: 400px;
  border: 3px solid #00c9ff;
  border-radius: 10px;
  box-shadow: 0 0 50px rgba(0, 201, 255, 0.5);
  margin-bottom: 30px;
  background: #0a0a1a;
  background-size: cover;
  background-position: center;
}

.analysis-results {
  display: flex;
  gap: 30px;
  margin-top: 20px;
  flex-wrap: wrap;
  justify-content: center;
}

.analysis-card {
  background: rgba(10, 10, 26, 0.9);
  padding: 20px;
  border-radius: 15px;
  width: 250px;
  text-align: center;
  transition: transform 0.3s, box-shadow 0.3s;
  border: 1px solid rgba(138, 43, 226, 0.3);
}

.analysis-card:hover {
  transform: translateY(-10px);
  box-shadow: 0 15px 30px rgba(138, 43, 226, 0.3);
}

.analysis-card h3 {
  color: #8a2be2;
  margin-bottom: 15px;
  font-size: 1.3rem;
}

.analysis-value {
  font-size: 2rem;
  font-weight: bold;
  color: #00c9ff;
  margin: 10px 0;
  text-shadow: 0 0 10px rgba(0, 201, 255, 0.7);
}

.analysis-label {
  font-size: 0.9rem;
  opacity: 0.8;
  line-height: 1.4;
}

.capture-buttons {
  display: flex;
  gap: 20px;
  margin-top: 30px;
  flex-wrap: wrap;
  justify-content: center;
}

footer {
  text-align: center;
  padding: 20px;
  font-size: 0.9rem;
  opacity: 0.7;
  z-index: 10;
  flex-shrink: 0;
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 10px;
}

::-webkit-scrollbar-track {
  background: rgba(10, 10, 26, 0.5);
  border-radius: 10px;
}

::-webkit-scrollbar-thumb {
  background: linear-gradient(45deg, #8a2be2, #00c9ff);
  border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(45deg, #00c9ff, #8a2be2);
}

/* Responsive adjustments */
@media (max-width: 1100px) {
  .main-container {
    flex-direction: column;
    height: auto;
  }
  
  .scroll-container {
    flex-direction: column;
  }
  
  .controls-section {
    max-width: 100%;
  }
  
  .visualizer-section {
    min-height: 70vh;
  }
}

@media (max-width: 768px) {
  .voice-image {
    width: 300px;
    height: 300px;
  }
  
  .capture-title {
    font-size: 2rem;
  }
  
  .capture-subtitle {
    font-size: 1rem;
  }
  
  .analysis-card {
    width: 100%;
    max-width: 300px;
  }
  
  .capture-buttons {
    flex-direction: column;
    gap: 15px;
  }
  
  .btn {
    width: 100%;
  }
}

@media (max-width: 480px) {
  h1 {
    font-size: 2rem;
  }
  
  .voice-image {
    width: 250px;
    height: 250px;
  }
  
  .analysis-results {
    gap: 15px;
  }
  
  .control-row {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .slider-value {
    text-align: left;
    margin-top: 5px;
  }
}

/* Animation for visual elements */
@keyframes float {
  0% { transform: translateY(0px); }
  50% { transform: translateY(-15px); }
  100% { transform: translateY(0px); }
}

.analysis-card {
  animation: float 4s ease-in-out infinite;
}

.analysis-card:nth-child(2) {
  animation-delay: 0.5s;
}

.analysis-card:nth-child(3) {
  animation-delay: 1s;
}

/* --------------------------------------------------------------------------
   Additional styles for cymatics pond controls and canvas responsivity
   -------------------------------------------------------------------------- */
.pond-canvas {
  width: 100%;
  height: 100%;
  display: block;
  border-radius: 12px;
  background: linear-gradient(180deg, rgba(11,31,51,0.6), rgba(2,6,23,0.4));
  outline: 1px solid rgba(255,255,255,0.02);
}
</style>
</head>
<body>
<header>
  <h1>Advanced Voice Frequency Art Generator</h1>
  <p class="subtitle">Create unique visual art from your voice patterns with enhanced controls and effects — now with Cymatics Pond visualization</p>
</header>

<div class="main-container">
  <div class="scroll-container">
    <div class="visualizer-section">
      <div class="visualization-container">

        <!-- NEW: Cymatics pond canvas container replaces old three.js container -->
        <div id="pond-container">
          <!-- We will dynamically insert the canvas here. Keep the capture overlay above it. -->
          <canvas id="pond-canvas" class="pond-canvas"></canvas>
          <!-- Retain capture overlay and analysis UI as in your original -->
          <div class="capture-overlay" id="captureOverlay">
            <h2 class="capture-title">Your Unique Voice Signature</h2>
            <p class="capture-subtitle">This visualization represents the unique frequency patterns of your voice. Every voice creates a distinct pattern based on frequency distribution, amplitude, and harmonics.</p>
            <div class="voice-image" id="voiceImage"></div>
            <div class="analysis-results">
              <div class="analysis-card">
                <h3>Dominant Frequency</h3>
                <div class="analysis-value" id="domFreq">220 Hz</div>
                <div class="analysis-label">The most prominent frequency in your voice signature</div>
              </div>
              <div class="analysis-card">
                <h3>Frequency Range</h3>
                <div class="analysis-value" id="freqRange">85-280 Hz</div>
                <div class="analysis-label">Range of detected frequencies in your voice sample</div>
              </div>
              <div class="analysis-card">
                <h3>Voice Signature</h3>
                <div class="analysis-value" id="voiceType">Warm</div>
                <div class="analysis-label">Characteristics of your vocal pattern</div>
              </div>
            </div>
            <div class="capture-buttons">
              <button class="btn btn-reset" id="resetBtn">
                <i class="icon">↻</i> Create Another
              </button>
              <button class="btn btn-save" id="saveBtn">
                <i class="icon">💾</i> Save Image
              </button>
            </div>
          </div>
        </div>

      </div>
    </div>
    
    <div class="controls-section">
      <div class="control-group">
        <h2 class="section-title"><i>🎚️</i> Visualization Controls</h2>
        <div class="control-row">
          <div class="control-label">Sensitivity</div>
          <input type="range" min="0.5" max="5" value="1.8" step="0.1" class="slider" id="sensitivity">
          <div class="slider-value" id="sensitivityValue">1.8</div>
        </div>
        <div class="control-row">
          <div class="control-label">Base Frequency</div>
          <input type="range" min="50" max="600" value="220" step="10" class="slider" id="baseFreq">
          <div class="slider-value" id="baseFreqValue">220 Hz</div>
        </div>
        <div class="control-row">
          <div class="control-label">Complexity</div>
          <input type="range" min="1" max="40" value="16" step="1" class="slider" id="complexity">
          <div class="slider-value" id="complexityValue">16</div>
        </div>
        <div class="control-row">
          <div class="control-label">Color Intensity</div>
          <input type="range" min="0.1" max="1.5" value="0.8" step="0.1" class="slider" id="colorIntensity">
          <div class="slider-value" id="colorIntensityValue">0.8</div>
        </div>
        <div class="control-row">
          <div class="control-label">Wave Speed</div>
          <input type="range" min="0.5" max="3" value="1.5" step="0.1" class="slider" id="waveSpeed">
          <div class="slider-value" id="waveSpeedValue">1.5</div>
        </div>
      </div>
      
      <div class="control-group">
        <h2 class="section-title"><i>🎤</i> Voice Recording</h2>
        <div class="btn-group">
          <button class="btn btn-record" id="recordBtn">
            <i class="icon">●</i> Start 10-Second Recording
          </button>
          <button class="btn" id="toggleMic">
            <i class="icon">🎤</i> Toggle Microphone
          </button>
          <button class="btn" id="sampleBtn">
            <i class="icon">🎵</i> Play Sample Voice
          </button>
        </div>
        
        <div class="recording-indicator" id="recIndicator" style="display: none;">
          <div class="dot"></div>
          <div>Recording in progress...</div>
        </div>
        
        <div class="countdown" id="countdown" style="display: none;"></div>
      </div>
      
      <div class="freq-analysis">
        <h2 class="freq-title">Live Frequency Analysis</h2>
        <div class="freq-details">
          <div class="freq-item">
            <div class="freq-label">Bass (0-200Hz)</div>
            <div class="freq-value" id="lowFreq">0 Hz</div>
          </div>
          <div class="freq-item">
            <div class="freq-label">Mid (200-2000Hz)</div>
            <div class="freq-value" id="midFreq">0 Hz</div>
          </div>
          <div class="freq-item">
            <div class="freq-label">Treble (2k-20kHz)</div>
            <div class="freq-value" id="highFreq">0 Hz</div>
          </div>
          <div class="freq-item">
            <div class="freq-label">Dominant Frequency</div>
            <div class="freq-value" id="domFreqLive">0 Hz</div>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <h2 class="section-title"><i>✨</i> Advanced Effects</h2>
        <div class="btn-group">
          <button class="btn" id="effect1">
            <i class="icon">🌀</i> Vortex Effect
          </button>
          <button class="btn" id="effect2">
            <i class="icon">🌌</i> Galaxy Effect
          </button>
          <button class="btn" id="effect3">
            <i class="icon">❄️</i> Crystal Effect
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<footer>
  <p>Advanced Voice Frequency Visualization | Created with Web Audio API & Canvas Cymatics | Enhanced with Rich Voice Classification</p>
</footer>

<script>
/* --------------------------------------------------------------------------
   DOM references (original ones preserved)
   -------------------------------------------------------------------------- */
const recordBtn = document.getElementById('recordBtn');
const resetBtn = document.getElementById('resetBtn');
const toggleMicBtn = document.getElementById('toggleMic');
const saveBtn = document.getElementById('saveBtn');
const sampleBtn = document.getElementById('sampleBtn');
const recIndicator = document.getElementById('recIndicator');
const countdownEl = document.getElementById('countdown');
const captureOverlay = document.querySelector('.capture-overlay');
const voiceImage = document.getElementById('voiceImage');
const lowFreqEl = document.getElementById('lowFreq');
const midFreqEl = document.getElementById('midFreq');
const highFreqEl = document.getElementById('highFreq');
const domFreqLiveEl = document.getElementById('domFreqLive');
const domFreqEl = document.getElementById('domFreq');
const freqRangeEl = document.getElementById('freqRange');
const voiceTypeEl = document.getElementById('voiceType') || document.getElementById('voiceType') ; // keep safe

// Slider value displays
const sensitivityValue = document.getElementById('sensitivityValue');
const baseFreqValue = document.getElementById('baseFreqValue');
const complexityValue = document.getElementById('complexityValue');
const colorIntensityValue = document.getElementById('colorIntensityValue');
const waveSpeedValue = document.getElementById('waveSpeedValue');

// Update slider values
document.getElementById('sensitivity').addEventListener('input', (e) => {
  sensitivityValue.textContent = e.target.value;
});

document.getElementById('baseFreq').addEventListener('input', (e) => {
  baseFreqValue.textContent = e.target.value + ' Hz';
});

document.getElementById('complexity').addEventListener('input', (e) => {
  complexityValue.textContent = e.target.value;
});

document.getElementById('colorIntensity').addEventListener('input', (e) => {
  colorIntensityValue.textContent = e.target.value;
});

document.getElementById('waveSpeed').addEventListener('input', (e) => {
  waveSpeedValue.textContent = e.target.value;
});

/* --------------------------------------------------------------------------
   Audio / Analysis variables
   - We'll only use a single AudioContext and Analyser for both UI and visualization
   - The Cymatics pond code will create audioCtx / analyser when the user starts.
   -------------------------------------------------------------------------- */
let audioCtx = null;
let analyser = null;
let dataArray = null;
let micStream = null;
let micActive = false;
let isRecording = false;
let recordingTimer = null;
let capturedDataURL = null;
let autoStopTimeout = null; // will hold auto-stop timeout id

/* --------------------------------------------------------------------------
   Enhanced voice detection logic (keeps your original flavor but expanded)
   - This function returns a rich object + a human-readable label.
   -------------------------------------------------------------------------- */
function safeRatio(a, b) {
  if (!b || b === 0) return 0;
  return a / b;
}

function detectVoiceSignature(domHz, lowN, midN, highN) {
  // domHz: dominant frequency in Hz (rounded)
  // lowN, midN, highN: normalized band energies 0..1

  // Pitch categories
  let pitchBucket = '';
  if (domHz < 85) pitchBucket = 'Extreme Low';
  else if (domHz < 110) pitchBucket = 'Very Low (Bass)';
  else if (domHz < 140) pitchBucket = 'Low (Baritone)';
  else if (domHz < 180) pitchBucket = 'Mid-Low (Tenor/Alto)';
  else if (domHz < 240) pitchBucket = 'Mid (Alto/Tenor)';
  else if (domHz < 320) pitchBucket = 'High (Soprano/High Tenor)';
  else pitchBucket = 'Very High (Soprano)';

  // Spectral descriptors
  let spectral = '';
  let trebleToMid = safeRatio(highN, midN);
  let midToLow = safeRatio(midN, lowN);

  if (highN > 0.45 && midN < 0.25) spectral = 'Breathy/Airy';
  else if (midN > 0.5 && lowN < 0.25 && highN < 0.25) spectral = 'Nasal';
  else if (lowN > 0.45 && midN > 0.4 && highN < 0.3) spectral = 'Gravelly/Throaty';
  else if (highN > 0.35 && midN > 0.35) spectral = 'Bright/Clear';
  else if (lowN > 0.35 && midN > 0.3) spectral = 'Warm/Smooth';
  else if (trebleToMid > 1.8 && highN > 0.3) spectral = 'Sharp/Piercing';
  else spectral = 'Neutral';

  // harmonic richness
  const harmonicIndex = (lowN + midN + highN) / 3;
  let richness = '';
  if (harmonicIndex > 0.5) richness = 'Rich Harmonics';
  else if (harmonicIndex < 0.25) richness = 'Thin/Tonal';
  else richness = 'Moderate Harmonics';

  // gender suggestion (rough)
  let genderSuggestion = '';
  if (domHz < 165) genderSuggestion = 'Likely Male Range';
  else genderSuggestion = 'Likely Female Range';

  // descriptive label
  let descriptors = [];
  if (domHz < 110) descriptors.push('Deep');
  else if (domHz < 180) descriptors.push('Warm');
  else if (domHz < 260) descriptors.push('Bright');
  else descriptors.push('Crisp');

  descriptors.push(spectral);
  descriptors.push(richness);

  const label = `${descriptors.join(' • ')} (${genderSuggestion})`;

  return {
    label,
    pitchBucket,
    spectral,
    richness,
    genderSuggestion,
    domHz,
    lowN,
    midN,
    highN
  };
}

/* --------------------------------------------------------------------------
   Cymatics Pond code (adapted & integrated)
   - start/stop exposed as __pondStart and __pondStop
   -------------------------------------------------------------------------- */
(function(){
  const canvas = document.getElementById('pond-canvas');
  const ctx = canvas.getContext('2d');

  let rafId = null;
  let streamLocal = null;
  let ripples = [];

  function fitCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * devicePixelRatio) || Math.floor(window.innerWidth * devicePixelRatio);
    canvas.height = Math.floor(rect.height * devicePixelRatio) || Math.floor(window.innerHeight * devicePixelRatio);
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  function spawnRipple(x, y, intensity){
    ripples.push({x, y, radius:6 + intensity*6, life:1.0, width:2 + intensity*3});
    if(ripples.length>40) ripples.splice(0, ripples.length-40);
  }

  function drawPond(){
    const w = canvas.width / devicePixelRatio;
    const h = canvas.height / devicePixelRatio;
    const g = ctx.createRadialGradient(w/2, h/3, 10, w/2, h/2, Math.max(w,h));
    g.addColorStop(0,'rgba(96,224,255,0.06)');
    g.addColorStop(0.35,'rgba(6,30,48,0.6)');
    g.addColorStop(1,'rgba(2,6,23,0.95)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }

  function drawRipples(){
    const w = canvas.width/devicePixelRatio;
    const h = canvas.height/devicePixelRatio;
    for(let i = ripples.length-1; i>=0; i--){
      const r = ripples[i];
      ctx.beginPath();
      ctx.arc(r.x * w, r.y * h, r.radius, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(96,224,255,${0.15 * r.life})`;
      ctx.lineWidth = r.width * r.life;
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(r.x * w, r.y * h, r.radius*0.25, 0, Math.PI*2);
      ctx.fillStyle = `rgba(96,224,255,${0.02 * r.life})`;
      ctx.fill();

      r.radius += 1.5 + (1-r.life)*6;
      r.life -= 0.015 + (0.02 * (1 - r.life));
      if(r.life<=0) ripples.splice(i,1);
    }
  }

  function drawCentralShape(freqData, normAmp){
    const w = canvas.width/devicePixelRatio;
    const h = canvas.height/devicePixelRatio;
    const cx = w/2;
    const cy = h/2.6;
    const bands = 64;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.beginPath();
    for(let i=0;i<bands;i++){
      const angle = (i/bands) * Math.PI*2;
      const fi = Math.floor(i*(freqData.length/bands));
      const v = freqData[fi]/255;
      const r = 60 + v*220* (0.6 + normAmp*0.8);
      const x = Math.cos(angle)*r;
      const y = Math.sin(angle)*r*0.6;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    const g = ctx.createLinearGradient(-200,-200,200,200);
    g.addColorStop(0,'rgba(96,224,255,0.10)');
    g.addColorStop(1,'rgba(6,180,200,0.03)');
    ctx.fillStyle = g;
    ctx.fill();
    ctx.lineWidth = 1.6 + normAmp*4;
    ctx.strokeStyle = `rgba(96,224,255,${0.5 + normAmp*0.5})`;
    ctx.stroke();
    ctx.restore();
  }

  function drawBars(dataArray){
    const w = canvas.width/devicePixelRatio;
    const h = canvas.height/devicePixelRatio;
    const barCount = 64;
    const bw = w / barCount;
    for(let i=0;i<barCount;i++){
      const fi = Math.floor(i*(dataArray.length/barCount));
      const val = dataArray[fi]/255;
      const bh = val*80;
      ctx.fillStyle = `rgba(96,224,255,${0.08 + val*0.35})`;
      ctx.fillRect(i*bw, h- bh - 8, bw*0.85, bh);
    }
  }

  function computeBandsAndDom(dataArray){
    if(!dataArray || dataArray.length === 0) return {lowN:0, midN:0, highN:0, domHz:0, domIndex:0};
    const binCount = dataArray.length;
    const lowEnd = Math.max(1, Math.floor(binCount * 0.1));
    const midEnd = Math.max(lowEnd + 1, Math.floor(binCount * 0.5));
    let lowSum = 0, midSum = 0, highSum = 0;
    for (let i = 0; i < lowEnd; i++) lowSum += dataArray[i];
    for (let i = lowEnd; i < midEnd; i++) midSum += dataArray[i];
    for (let i = midEnd; i < binCount; i++) highSum += dataArray[i];
    const lowN = lowSum / (lowEnd || 1) / 255;
    const midN = midSum / (midEnd - lowEnd || 1) / 255;
    const highN = highSum / (binCount - midEnd || 1) / 255;

    let maxFreqVal = 0, maxFreqIndex = 0;
    for (let i = 0; i < binCount; i++){
      if (dataArray[i] > maxFreqVal){
        maxFreqVal = dataArray[i];
        maxFreqIndex = i;
      }
    }
    const sampleRate = (audioCtx && audioCtx.sampleRate) ? audioCtx.sampleRate : 44100;
    const nyquist = sampleRate / 2;
    const domHz = Math.round(maxFreqIndex * nyquist / binCount);

    return {lowN, midN, highN, domHz, domIndex:maxFreqIndex};
  }

  function draw(){
    if(!analyser || !dataArray) {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      rafId = requestAnimationFrame(draw);
      return;
    }

    analyser.getByteFrequencyData(dataArray);

    let sum = 0;
    for(let i=0;i<dataArray.length;i++) sum += dataArray[i];
    const avg = sum / dataArray.length;
    const norm = avg / 255;

    drawPond();

    const sensUI = document.getElementById('sensitivity');
    const uiSens = sensUI ? parseFloat(sensUI.value) : 2;
    const spawnThreshold = 0.08 * (1/uiSens);
    if(norm > spawnThreshold){
      const rx = 0.48 + (Math.random()-0.5) * 0.22;
      const ry = 0.4 + (Math.random()-0.5) * 0.22;
      spawnRipple(rx, ry, Math.min(6, norm*10));
    }

    drawCentralShape(dataArray, norm);
    drawRipples();
    drawBars(dataArray);

    const bands = computeBandsAndDom(dataArray);
    lowFreqEl.textContent = Math.round(bands.lowN * 300) + ' Hz';
    midFreqEl.textContent = Math.round(bands.midN * 1000) + ' Hz';
    highFreqEl.textContent = Math.round(bands.highN * 5000) + ' Hz';
    domFreqLiveEl.textContent = bands.domHz + ' Hz';

    try {
      const detected = detectVoiceSignature(bands.domHz, bands.lowN, bands.midN, bands.highN);
      if(document.getElementById('voiceType')) {
        document.getElementById('voiceType').textContent = detected.label;
      }
    } catch(e) {
      // ignore
    }

    rafId = requestAnimationFrame(draw);
  }

  async function startAudioForPond(){
    if(audioCtx) return;
    try {
      streamLocal = await navigator.mediaDevices.getUserMedia({audio:true, video:false});
    } catch(e) {
      alert('Microphone access denied or not available.');
      console.error(e);
      return;
    }
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    const bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);
    const source = audioCtx.createMediaStreamSource(streamLocal);
    source.connect(analyser);

    micStream = streamLocal;
    micActive = true;

    fitCanvas();
    draw();
  }

  function stopAudioForPond(){
    if(rafId) cancelAnimationFrame(rafId);
    try { if(streamLocal) streamLocal.getTracks().forEach(t=>t.stop()); } catch(e){/*ignore*/}
    try { if(audioCtx) audioCtx.close(); } catch(e){/*ignore*/}
    audioCtx = null;
    analyser = null;
    dataArray = null;
    streamLocal = null;
    micStream = null;
    micActive = false;
    ripples = [];
    ctx.clearRect(0,0,canvas.width,canvas.height);
    fitCanvas();
  }

  window.__pondStart = startAudioForPond;
  window.__pondStop = stopAudioForPond;
})(); // end pond IIFE

/* --------------------------------------------------------------------------
   Utility: start pond and auto-stop after duration (ms) - used for recording
   -------------------------------------------------------------------------- */
async function startPondWithAutoStop(durationMs = 10000) {
  // clear any previous auto-stop timers
  if (autoStopTimeout) {
    clearTimeout(autoStopTimeout);
    autoStopTimeout = null;
  }
  if (typeof window.__pondStart === 'function') {
    await window.__pondStart();
    micActive = true;
  }
  // schedule auto-stop
  autoStopTimeout = setTimeout(() => {
    if (typeof window.__pondStop === 'function') {
      window.__pondStop();
      micActive = false;
    }
    autoStopTimeout = null;
  }, durationMs);
}

/* --------------------------------------------------------------------------
   Initialize audio (fallback)
   -------------------------------------------------------------------------- */
function initAudio() {
  if (audioCtx && analyser && dataArray) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 4096;
  dataArray = new Uint8Array(analyser.frequencyBinCount);
}

/* --------------------------------------------------------------------------
   Toggle microphone
   - If turning on, start pond with auto-stop disabled so user can toggle off manually.
   -------------------------------------------------------------------------- */
async function toggleMic() {
  if (micActive) {
    try { if (micStream) micStream.getTracks().forEach(t=>t.stop()); } catch(e){}
    micActive = false;
    micStream = null;
    toggleMicBtn.innerHTML = '<i class="icon">🎤</i> Start Microphone';
    if (typeof window.__pondStop === 'function') {
      window.__pondStop();
    }
    if (autoStopTimeout) { clearTimeout(autoStopTimeout); autoStopTimeout = null; }
    return;
  }

  if (audioCtx && analyser && dataArray && micStream) {
    micActive = true;
    toggleMicBtn.innerHTML = '<i class="icon">🎤</i> Stop Microphone';
    return;
  }

  if (typeof window.__pondStart === 'function') {
    // start without auto-stop when toggling mic manually
    await window.__pondStart();
    micActive = true;
    toggleMicBtn.innerHTML = '<i class="icon">🎤</i> Stop Microphone';
    return;
  }

  try {
    if (!audioCtx) initAudio();
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const src = audioCtx.createMediaStreamSource(micStream);
    src.connect(analyser);
    if (audioCtx.state === 'suspended') await audioCtx.resume();
    micActive = true;
    toggleMicBtn.innerHTML = '<i class="icon">🎤</i> Stop Microphone';
  } catch (err) {
    console.error('Microphone access error:', err);
    alert('Could not access microphone. Please check permissions and try again.');
  }
}

/* --------------------------------------------------------------------------
   Start 10-second recording flow
   - starts pond with auto-stop (10s)
   - shows UI countdown
   -------------------------------------------------------------------------- */
function startRecording() {
  if (isRecording) return;
  isRecording = true;
  recIndicator.style.display = 'flex';
  countdownEl.style.display = 'block';
  recordBtn.disabled = true;

  let secondsLeft = 10;
  countdownEl.textContent = secondsLeft;

  // Start pond and schedule auto-stop after 10s
  startPondWithAutoStop(10000);

  // UI countdown
  if (recordingTimer) clearInterval(recordingTimer);
  recordingTimer = setInterval(() => {
    secondsLeft--;
    countdownEl.textContent = secondsLeft;
    if (secondsLeft <= 0) {
      clearInterval(recordingTimer);
      recordingTimer = null;
      finishRecording();
    }
  }, 1000);
}

// Called after recording countdown finishes to compute and show results
function finishRecording() {
  isRecording = false;
  recIndicator.style.display = 'none';
  countdownEl.style.display = 'none';
  recordBtn.disabled = false;

  // compute final analysis after a short delay to ensure analyser captured last frames
  setTimeout(() => {
    if (analyser && dataArray) {
      // compute bands/dom similar to pond helper
      const binCount = dataArray.length;
      const lowEnd = Math.max(1, Math.floor(binCount * 0.1));
      const midEnd = Math.max(lowEnd + 1, Math.floor(binCount * 0.5));
      let lowSum = 0, midSum = 0, highSum = 0;
      for (let i = 0; i < lowEnd; i++) lowSum += dataArray[i];
      for (let i = lowEnd; i < midEnd; i++) midSum += dataArray[i];
      for (let i = midEnd; i < binCount; i++) highSum += dataArray[i];
      const lowN = lowSum / (lowEnd || 1) / 255;
      const midN = midSum / (midEnd - lowEnd || 1) / 255;
      const highN = highSum / (binCount - midEnd || 1) / 255;

      let maxFreqVal = 0, maxFreqIndex = 0;
      for (let i = 0; i < binCount; i++) {
        if (dataArray[i] > maxFreqVal) {
          maxFreqVal = dataArray[i];
          maxFreqIndex = i;
        }
      }
      const sampleRate = audioCtx ? audioCtx.sampleRate : 44100;
      const nyquist = sampleRate / 2;
      const domHz = Math.round(maxFreqIndex * nyquist / binCount);

      domFreqEl.textContent = domHz + ' Hz';
      const lowRange = Math.round(domHz * 0.4);
      const highRange = Math.round(domHz * 1.4);
      freqRangeEl.textContent = lowRange + '-' + highRange + ' Hz';

      const detected = detectVoiceSignature(domHz, lowN, midN, highN);
      if (voiceTypeEl) voiceTypeEl.textContent = detected.label;

      // Capture visualization snapshot
      try {
        const pondCanvas = document.getElementById('pond-canvas');
        if (pondCanvas) {
          capturedDataURL = pondCanvas.toDataURL('image/png');
          voiceImage.style.backgroundImage = `url(${capturedDataURL})`;
        }
      } catch (err) {
        console.warn('Could not capture canvas:', err);
      }
    } else {
      domFreqEl.textContent = 'N/A';
      freqRangeEl.textContent = 'N/A';
      if (voiceTypeEl) voiceTypeEl.textContent = 'N/A';
    }

    // Show overlay results
    captureOverlay.classList.add('active');

    // Stop pond audio if auto-stop hasn't already (safety)
    if (typeof window.__pondStop === 'function') {
      window.__pondStop();
      if (autoStopTimeout) { clearTimeout(autoStopTimeout); autoStopTimeout = null; }
      micActive = false;
    }
  }, 150);
}

// Play sample voice and use analyser so pond sees it. Auto-stop pond after 10s.
function playSampleVoice() {
  if (!audioCtx) initAudio();

  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();

  oscillator.type = 'sawtooth';
  const now = audioCtx.currentTime;
  oscillator.frequency.setValueAtTime(120, now);
  oscillator.frequency.exponentialRampToValueAtTime(280, now + 0.5);
  oscillator.frequency.exponentialRampToValueAtTime(180, now + 1.0);

  gainNode.gain.setValueAtTime(0.8, now);
  gainNode.gain.setValueAtTime(0.2, now + 0.3);
  gainNode.gain.setValueAtTime(0.7, now + 0.6);
  gainNode.gain.setValueAtTime(0.1, now + 0.9);

  if (analyser) {
    oscillator.connect(gainNode);
    gainNode.connect(analyser);
  } else {
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
  }

  oscillator.start();

  // Ensure pond is running and schedule stop after 10s
  startPondWithAutoStop(10000);

  setTimeout(() => {
    oscillator.stop();
  }, 10000);

  // show UI while sample plays
  isRecording = true;
  recIndicator.style.display = 'flex';
  countdownEl.style.display = 'block';
  recordBtn.disabled = true;

  let secondsLeft = 10;
  countdownEl.textContent = secondsLeft;

  if (recordingTimer) clearInterval(recordingTimer);
  recordingTimer = setInterval(() => {
    secondsLeft--;
    countdownEl.textContent = secondsLeft;
    if (secondsLeft <= 0) {
      clearInterval(recordingTimer);
      recordingTimer = null;
      // finish sample play UI
      isRecording = false;
      recIndicator.style.display = 'none';
      countdownEl.style.display = 'none';
      recordBtn.disabled = false;
      // Capture snapshot & show overlay similar to finishRecording
      setTimeout(() => {
        try {
          const pondCanvas = document.getElementById('pond-canvas');
          if (pondCanvas) {
            capturedDataURL = pondCanvas.toDataURL('image/png');
            voiceImage.style.backgroundImage = `url(${capturedDataURL})`;
          }
          captureOverlay.classList.add('active');
        } catch(e){}
      }, 150);
    }
  }, 1000);
}

// Stop recording (manual stop)
function stopRecording() {
  if (recordingTimer) { clearInterval(recordingTimer); recordingTimer = null; }
  isRecording = false;
  recIndicator.style.display = 'none';
  countdownEl.style.display = 'none';
  recordBtn.disabled = false;

  // Stop pond/audio
  if (typeof window.__pondStop === 'function') {
    window.__pondStop();
    if (autoStopTimeout) { clearTimeout(autoStopTimeout); autoStopTimeout = null; }
    micActive = false;
  }

  // Show overlay and compute results like finishRecording
  finishRecording();
}

// Save image
function saveImage() {
  if (!capturedDataURL) {
    alert('No image to save. Please create a voice signature first.');
    return;
  }
  const link = document.createElement('a');
  link.download = 'voice-frequency-art.png';
  link.href = capturedDataURL;
  link.click();
}

// Reset visualization
function resetVisualization() {
  captureOverlay.classList.remove('active');
  capturedDataURL = null;
}

/* --------------------------------------------------------------------------
   UI wiring
   -------------------------------------------------------------------------- */
toggleMicBtn.addEventListener('click', toggleMic);
recordBtn.addEventListener('click', startRecording);
sampleBtn.addEventListener('click', playSampleVoice);
resetBtn.addEventListener('click', resetVisualization);
saveBtn.addEventListener('click', saveImage);

document.getElementById('effect1').addEventListener('click', () => {
  console.info('Vortex effect toggle pressed (no-op for pond).');
});
document.getElementById('effect2').addEventListener('click', () => {
  console.info('Galaxy effect toggle pressed (no-op for pond).');
});
document.getElementById('effect3').addEventListener('click', () => {
  console.info('Crystal effect toggle pressed (no-op for pond).');
});

window.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    e.preventDefault();
    if (!audioCtx) {
      if (typeof window.__pondStart === 'function') window.__pondStart();
    } else {
      if (typeof window.__pondStop === 'function') window.__pondStop();
    }
  }
});

// keep toggleMicBtn label synced
setInterval(() => {
  if (micActive) {
    toggleMicBtn && (toggleMicBtn.innerHTML = '<i class="icon">🎤</i> Stop Microphone');
  } else {
    toggleMicBtn && (toggleMicBtn.innerHTML = '<i class="icon">🎤</i> Start Microphone');
  }
}, 1000);

</script>
</body>
</html>
